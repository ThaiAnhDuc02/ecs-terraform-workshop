[
{
	"uri": "//localhost:1313/vi/2-preparation/1-dependencies/",
	"title": "Chuẩn bị các phụ thuộc",
	"tags": [],
	"description": "",
	"content": "Kiến thức cốt lõi Để chuẩn bị tốt hơn cho Workshop này, bạn nên tham khảo ba bài tập trong AWS Study Group:\nDeploy Application on Docker Container. Deploy applications on Amazon Elastic Container Service. Deploying CI/CD with ECS Container Khi các bạn hoàn thành tốt những bài trên, sẽ giúp các bạn có thể nắm rõ:\nCách triển khai hạ tầng trên AWS. Sử dụng RDS để quản lý database. Tạo ECS để chạy container cho ứng dụng. Sử dụng Application Load Balancer để phân phối tải đồng đều. Thiết lập CI/CD để tự động hóa việc cập nhật và triển khai ứng dụng. Theo dõi và giám sát hiệu suất của các quy trình. Sau khi đã hiểu rõ các thành phần trên, các bạn sẽ đến với cách để triển khai hạ tầng một cách nhanh chóng chỉ bằng vài dòng lệnh khi sử dụng Terraform. Bây giờ, hãy cùng bắt đầu Workshop và khám phá từng bước nhé!\nCài đặt các phụ thuộc Để bắt đầu chạy mã trong Terraform, bạn cần:\nCài đặt Terraform CLI: Công cụ dòng lệnh này giúp bạn quản lý và triển khai hạ tầng dưới dạng mã. Cài đặt AWS CLI: Công cụ này cho phép Terraform tương tác trực tiếp với các dịch vụ AWS, giúp dễ dàng quản lý tài nguyên trên đám mây. Hãy chọn phiên bản phù hợp với hệ điều hành của bạn. Bạn có thể tham khảo hướng dẫn chi tiết cách cài đặt trong video dưới đây.\n"
},
{
	"uri": "//localhost:1313/vi/7-cicd-github/1-template/",
	"title": "Clone GitHub template",
	"tags": [],
	"description": "",
	"content": " Trong phần này, chúng tôi cung cấp sẵn một template mẫu để chạy CI/CD bằng GitHub Actions. Bạn có thể tham khảo và clone về để dễ dàng hơn trong việc thiết lập và sử dụng, giúp quá trình triển khai CI/CD trở nên nhanh chóng và hiệu quả hơn. Ngoài ra bạn có thể tự cấu hình phần CI/CD của mình để quản lý code của mình dễ dàng hơn.\nGit clone mã nguồn trên GitHub Bạn sẽ sử dụng lại máy ảo EC2 ở phần trước để clone code này về và chỉnh sửa trong nó. Sau khi đã có code, bạn có thể chỉnh sửa theo yêu cầu của bạn cho phù hợp.\nSử dụng lệnh sau để kiểm tra và clone code. Sau đó truy cập vào trong folder để sửa code theo yêu cầu. git -v git clone https://github.com/LyHoangViet/cicd-github-action-ws17.git ls cd ./cicd-github-action-ws17/ Chỉnh sửa lại source code ở phần sau để có thể làm ví dụ khi run một CI/CD trong Github action sẽ được thay đổi.\nĐường dẫn: frontend/src/components/Menu.jsx Dòng 68 ở trong file, mình có thể sửa như ở dưới (hoặc sửa theo ý muốn tùy vào yêu cầu). Giải thích code Đầu tiên sẽ là file main.yml sẽ chứa tất cả những công việc của frontend và backend.\nCách truy cập vào file: vi .github/workflows/main.yml name: CI/CD Pipeline on: push: tags: - \u0026#39;*\u0026#39; jobs: frontend: uses: ./.github/workflows/frontend.yml secrets: inherit backend: uses: ./.github/workflows/backend.yml secrets: inherit Trong đó:\nname: CI/CD Pipeline là cấu trúc của workflow on: (…) là sự kiện kích hoạt workflow jobs: (…) là những jobs sẽ được hoạt động khi run CI/CD Tiếp theo sẽ là file backend.yml và file frontend.yml là nơi sẽ cấu hình jobs cụ thể 2 phần này. Bởi vì cấu hình cũng khá giống nhau nên mình xin phép hướng dẫn một file là file backend.yml\nCách truy cập vào file: vi .github/workflows/backend.yml name: Backend CI/CD on: workflow_call: # Use Docker Hub env: IMAGE_NAME_BE: ${{ secrets.DOCKER_USERNAME }}/backend:${{ github.ref_name }} jobs: # this comment need when you implement in prod env (1) # check_changes_backend: # runs-on: ubuntu-latest # outputs: # backend: ${{ steps.filter.outputs.backend }} # steps: # - uses: actions/checkout@v2 # - uses: dorny/paths-filter@v2 # id: filter # with: # filters: | # backend: # - \u0026#39;backend/**\u0026#39; build-and-push: # this comment need when you implement in prod env (1) # needs: check_changes_backend # if: ${{ needs.check_changes_backend.outputs.backend == \u0026#39;true\u0026#39; }} runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v2 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v1 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ secrets.AWS_REGION }} # Use Docker Hub - name: Login to Docker Hub uses: docker/login-action@v2 with: username: ${{ secrets.DOCKER_USERNAME }} password: ${{ secrets.DOCKER_PASSWORD }} - name: Build, tag, and push image to Amazon ECR working-directory: ./backend run: | docker build -f Dockerfile -t ${{ env.IMAGE_NAME_BE }} . docker push ${{ env.IMAGE_NAME_BE }} deploy: needs: build-and-push runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v2 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v1 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ secrets.AWS_REGION }} - name: Deploy Backend env: TASK_NAME_BE: ${{ secrets.TASK_NAME_BE }} IMAGE_NAME_BE: ${{ env.IMAGE_NAME_BE }} AWS_APPLICATION_NAME: ${{ secrets.AWS_APPLICATION_NAME }} AWS_DEPLOYMENT_GROUP_NAME: ${{ secrets.AWS_DEPLOYMENT_GROUP_NAME }} REGION: ${{ secrets.AWS_REGION }} run: bash backend/deploy-backend.sh Trong đó: name: Backend CI/CD là tên cấu trúc của workflow. on: (…) là sự kiện kích hoạt workflow cho phép gọi tới workflow khác. env: (…) dùng để định nghĩa các biến môi trường cho image (hiện đang dùng cho Docker hub có thể đổi qua ECR). build-and-push: (…) là một workflow trong jobs chính, sử dụng để build một image và push lên Docker hub. deploy: (…) là một jobs thứ 2 dùng để deploy image vừa được build lên ECS. run: bash backend/deploy-backend.sh phần cuối này sẽ dẫn đên file dùng để deploy. Cuối cùng mình sẽ cần phải truy cập vào file deploy-backend.sh hoặc ở bên frontend là file deploy-frontend.sh để cấu hình code khi deploy ECS.\nCách truy cập vào file: vi backend/deploy-backend.sh #!/bin/bash # Retrieve the task definition from ECS TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition \u0026#34;$TASK_NAME_BE\u0026#34; --region \u0026#34;$REGION\u0026#34;) # Register a new task definition with an updated image NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE \u0026#34;$IMAGE_NAME_BE\u0026#34; \u0026#39;.taskDefinition | .containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)\u0026#39;) NEW_REVISION=$(aws ecs register-task-definition --region \u0026#34;$REGION\u0026#34; --cli-input-json \u0026#34;$NEW_TASK_DEFINITION\u0026#34;) echo $NEW_REVISION | jq \u0026#39;.taskDefinition.revision\u0026#39; # Extract the task definition ARN, container name, and container port using jq AWS_TASK_DEFINITION_ARN=$(echo $TASK_DEFINITION | jq -r \u0026#39;.taskDefinition.taskDefinitionArn\u0026#39;) CONTAINER_NAME=$(echo $TASK_DEFINITION | jq -r \u0026#39;.taskDefinition.containerDefinitions[0].name\u0026#39;) CONTAINER_PORT=$(echo $TASK_DEFINITION | jq -r \u0026#39;.taskDefinition.containerDefinitions[0].portMappings[0].containerPort\u0026#39;) # Create the application specification (AppSpec) in JSON format APP_SPEC=$(jq -n --arg taskDef \u0026#34;$AWS_TASK_DEFINITION_ARN\u0026#34; --arg containerName \u0026#34;$CONTAINER_NAME\u0026#34; --argjson containerPort \u0026#34;$CONTAINER_PORT\u0026#34; \u0026#39;{ version: \u0026#34;0.0\u0026#34;, Resources: [ { TargetService: { Type: \u0026#34;AWS::ECS::Service\u0026#34;, Properties: { TaskDefinition: $taskDef, LoadBalancerInfo: { ContainerName: $containerName, ContainerPort: $containerPort } } } } ] }\u0026#39;) # Create the revision configuration for the deployment REVISION=$(jq -n --arg appSpec \u0026#34;$APP_SPEC\u0026#34; \u0026#39;{ revisionType: \u0026#34;AppSpecContent\u0026#34;, appSpecContent: { content: $appSpec } }\u0026#39;) # Trigger the deployment using the specified application name, deployment group, and revision aws deploy create-deployment --region \u0026#34;$REGION\u0026#34; \\ --application-name \u0026#34;$AWS_APPLICATION_NAME\u0026#34; \\ --deployment-group-name \u0026#34;$AWS_DEPLOYMENT_GROUP_NAME\u0026#34; \\ --revision \u0026#34;$REVISION\u0026#34; Kết quả: Task definition ECS được cập nhật với image mới. CodeDeploy kích hoạt deployment với cấu hình mới, đồng bộ hóa ứng dụng với image backend mới trong service ECS hiện có. "
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Bối cảnh Tại sao lại có bài Workshop này?\nTrong thực tế, triển khai hạ tầng AWS với Container thường phức tạp và tốn nhiều thời gian. Quy trình thủ công dễ dẫn đến lỗi cấu hình, khó kiểm soát, và lãng phí tài nguyên không cần thiết khi gặp sự cố. Terraform giải quyết những thách thức này bằng cách tự động hóa việc tạo và quản lý hạ tầng, giúp quy trình nhanh chóng và dễ dàng hơn. Khi kết hợp với CI/CD, việc triển khai trở nên tối ưu và dễ dàng theo dõi, giúp doanh nghiệp giảm rủi ro và cải thiện hiệu quả quản lý hệ thống.\nQuy trình này mang lại nhiều lợi ích rõ rệt:\nTiết kiệm thời gian và chi phí: Tự động hóa giảm thiểu công việc thủ công và tăng hiệu suất làm việc. Độ tin cậy cao: Các dịch vụ được triển khai đồng bộ, giảm thiểu lỗi do cấu hình. Khả năng mở rộng linh hoạt: Hạ tầng dễ dàng mở rộng hoặc thu hẹp theo nhu cầu, tối ưu hóa chi phí vận hành. Phản hồi nhanh chóng với thay đổi: CI/CD giúp cải tiến sản phẩm và cập nhật hệ thống nhanh hơn, đáp ứng tốt hơn nhu cầu thị trường. Nhờ quy trình này, công ty không chỉ đáp ứng tốt nhu cầu mở rộng mà còn tối ưu hóa chất lượng dịch vụ, gia tăng tính cạnh tranh và tăng cường sự hài lòng của khách hàng.\nTerraform là gì? Terraform là một công cụ mã nguồn mở do HashiCorp phát triển, dùng để quản lý hạ tầng (Infrastructure as Code - IaC). Nó cho phép người dùng định nghĩa và triển khai hạ tầng thông qua mã (code), giúp tự động hóa việc tạo, cập nhật, và quản lý các tài nguyên như máy chủ, cơ sở dữ liệu, mạng, và các dịch vụ khác trên các nền tảng điện toán đám mây như AWS, Azure, Google Cloud, và cả các hệ thống tại chỗ (on-premises).\nNhững điểm nổi bật của Terraform:\nQuản lý Hạ Tầng như Code (IaC): Hạ tầng được mô tả bằng mã, cho phép kiểm soát phiên bản, chia sẻ, và sao lưu cấu hình dễ dàng, tương tự như việc quản lý mã nguồn của ứng dụng. Triển khai và Cấu hình Tự động: Với Terraform, người dùng có thể triển khai hoặc thay đổi hàng loạt tài nguyên chỉ bằng một dòng lệnh, giúp tiết kiệm thời gian và giảm thiểu sai sót thủ công. Tính Độc lập với Nền Tảng: Terraform hỗ trợ nhiều nhà cung cấp đám mây khác nhau, giúp doanh nghiệp triển khai hạ tầng đa đám mây hoặc chuyển đổi dễ dàng giữa các nền tảng mà không cần thay đổi công cụ. Khả năng Quản lý Vòng đời Tài nguyên: Terraform không chỉ tạo mà còn quản lý toàn bộ vòng đời tài nguyên, bao gồm cập nhật, sửa đổi và xóa bỏ tài nguyên khi cần thiết. Tính Phân tách và Mở rộng: Terraform cho phép chia nhỏ hạ tầng thành các module, giúp việc quản lý trở nên linh hoạt, dễ bảo trì và dễ mở rộng khi hệ thống phát triển. Nhờ những ưu điểm trên, Terraform giúp đơn giản hóa quy trình quản lý hạ tầng, làm cho các thay đổi trở nên an toàn, kiểm soát được và dễ dàng triển khai trên quy mô lớn.\nGithub Action CI/CD GitHub Actions là dịch vụ tự động hóa tích hợp trên GitHub, giúp tự động hóa quy trình phát triển phần mềm từ kiểm tra mã nguồn đến triển khai ứng dụng, dễ dàng thiết lập CI/CD (Continuous Integration/Continuous Deployment).\nContinuous Integration (CI) Xây dựng và Kiểm tra Tự động: Tự động xây dựng và kiểm tra mã mỗi khi có thay đổi, giúp phát hiện lỗi sớm. Workflows: Định nghĩa các workflow để tự động thực hiện kiểm tra, xây dựng và phát hành mã khi có sự kiện như pull request hoặc commit mới. Continuous Deployment (CD) Triển khai Tự động: Hỗ trợ triển khai ứng dụng tự động lên các môi trường như staging hoặc production khi mã được chấp nhận. Tích hợp Dịch vụ: Dễ dàng tích hợp với các dịch vụ như AWS, Azure và Google Cloud. Tính Năng Nổi Bật Khả Năng Tùy Biến: Tạo các action tùy chỉnh hoặc sử dụng action từ GitHub Marketplace. Giao Diện Thân Thiện: Dễ dàng thiết lập và quản lý workflows mà không cần kiến thức sâu về scripting. Quản lý Tài Nguyên: Theo dõi trạng thái workflow và cung cấp thông tin chi tiết về quá trình kiểm tra và triển khai. Lợi Ích Tiết Kiệm Thời Gian: Giảm thiểu công việc lặp đi lặp lại cho nhà phát triển. Nâng Cao Chất Lượng Mã: Cải thiện chất lượng phần mềm nhờ kiểm tra và triển khai thường xuyên. Khả Năng Linh Hoạt: Dễ dàng điều chỉnh quy trình CI/CD để phù hợp với nhu cầu dự án. Monitoring với CloudWatch Container Insights CloudWatch Container Insights là một tính năng trong AWS CloudWatch, cung cấp khả năng giám sát và phân tích các container đang chạy trên Amazon ECS (Elastic Container Service) và EKS (Elastic Kubernetes Service). Dưới đây là một số điểm nổi bật của Container Insights:\nGiám sát Hiệu Suất: Container Insights cho phép bạn theo dõi các chỉ số hiệu suất quan trọng như CPU, bộ nhớ, và mạng cho từng container, giúp phát hiện sớm các vấn đề và tối ưu hóa hiệu suất ứng dụng. Thống Kê Tình Trạng Container: Bạn có thể xem thông tin chi tiết về tình trạng hoạt động của các container, bao gồm trạng thái của chúng (chạy, dừng, lỗi) và các thông số khác như thời gian chạy và số lượng bản sao. Tích Hợp Với AWS: Container Insights có thể dễ dàng tích hợp với các dịch vụ khác của AWS, cho phép bạn xây dựng các giải pháp giám sát toàn diện và tạo báo cáo tùy chỉnh dựa trên các chỉ số container. Dashboard Trực Quan: AWS cung cấp các dashboard trực quan cho phép bạn theo dõi tình trạng và hiệu suất của container một cách dễ dàng, cùng với khả năng thiết lập cảnh báo khi có sự cố xảy ra. Trước khi bắt đầu làm Workshop, mình khuyến khích các bạn nên dành chút thời gian tìm hiểu sơ lược về các nội dung sẽ thực hiện. Giờ thì chúng ta cùng bắt đầu và khám phá từng bước trong Workshop nhé. Chúc các bạn hoàn thành Workshop thật suôn sẻ và đạt kết quả tốt nhất!\n"
},
{
	"uri": "//localhost:1313/vi/3-terraform/1-introduce/",
	"title": "Giới thiệu về hạ tầng",
	"tags": [],
	"description": "",
	"content": "Hạ tầng Terraform Như đã giới thiệu từ trước, Terraform cho phép cấu hình hạ tầng đám mây trên AWS một cách tự động và có tổ chức. Và template được mình chuẩn bị dưới đây, đã viết sẵn code để triển khai hạ tầng và cáu trúc của template như sau:\nCó 4 file chính được thực hiện xuyên suốt trong cấu hình và thiết lập dịch vụ là:\nterraform.tf: Định cấu hình provider, đây là file cơ bản và thường ít thay đổi. variable.tf: Lưu trữ các biến, giúp dễ dàng điều chỉnh giá trị cho từng lần triển khai. main.tf: Đây là file chính để chạy các chương trình và dịch vụ cho hạ tầng đã được cấu hình. output.tf: Xuất kết quả của các tài nguyên sau khi triển khai, giúp tận dụng lại các giá trị này cho mục đích khác. Thư mục modules sẽ chứa các cấu hình của từng dịch vụ.\nCác file .tf nằm ngoài thư mục modules sẽ tổng hợp các dịch vụ lại, cho phép triển khai đồng bộ và tối ưu hóa quá trình.\nLink template: https://github.com/ThaiAnhDuc02/ecs-terraform.git\nĐể hiểu rõ hơn về các phần ở trong template mình đã viết sẵn, mình khuyên các bạn nên xem qua khóa học Terraform ở trên KodeKloud và tự viết cho mình một hạ tầng mới có thể tham khảo thêm về hạ tầng của template này.\nBạn có thể đọc file README để biến thêm thông tin về hạ tầng này. Cài đặt các công cụ cần thiết như đã hướng dẫn. "
},
{
	"uri": "//localhost:1313/vi/5-ecs-service/1-backend/",
	"title": "Triển khai Blue/Green và Service Scaling với Backend",
	"tags": [],
	"description": "",
	"content": "Tạo ECS Service Backend Bây giờ, chúng ta cần phải tạo ECS service để chạy các container ở trong đó.\nTìm kiếm từ khóa ECS trong AWS Console. Chọn Cluster mình đã tạo. Kéo xuống phần Service và chọn Create. Chúng ta sẽ cấu hình FARGATE để dễ dàng sử dụng hơn.\nChọn Launch type là FARGATE. Version chọn LATEST. Chọn type là Service. Family chọn Task definition đã tạo cho backend và chọn version mới nhất. Nhập tên: backend Chọn type là Replica và chọn 1 task để khởi chạy. Chọn deploy bằng Blue/Green. Chọn cấu hình deploy là CodeDeployDefault.ECSCanary10Percent5Minutes Phần Role chọn role đã tạo ở phần chuẩn bị CodeDeployServiceRole. Service discovery Phần này quan trọng, để cho Frontend Service và Backend Service thì chúng ta phải cấu hình Service discovery cho Backend Service với namespace và serivce đã tạo trong phần Cloud Map (Đã được cấu hình bằng Terraform).\nChọn Use service discovery. Chọn Select an existing namespace, chọn namespace fcjresbar.internal mà chúng ta đã được tạo trước đó. Chọn Select an existing service discovery service, chọn service backend. Các cấu hình còn lại để mặc định. Networking Giờ thì mình sẽ gán Service này và các container vào trong vùng mạng, subnet mà mình đã tạo sẵn bằng hạ tầng Terraform.\nVPC: Chọn VPC mà chúng ta đã tạo trước đó Subnet: Chọn private subnet (DoAn-network-subnet-private4) mà chúng ta đã tạo trong phần chuẩn bị Security group: Chọn DoAn-network-sg-private. Public ip: Phần này sẽ tắt để tăng tính bảo mật hơn vì traffic đã được truyền thông qua Load Balancer rồi. Load Balancing Cấu hình một số thông tin của Load Balancer như sau:\nLoad balancing type: Chọn Application Load Balancer Container: backend 5000:5000 (port ở đây sẽ là port của host và container) Chọn Use an existing load balancer Chọn Doan-alb load balancer Health Check: Giữ mặc định. Phần Listener ta sẽ tạo mới 2 Listener.\nProduction listener: port 5000, protocol HTTP Test listener: port 8080, protocol HTTP Phần của target group sẽ được giữ mặc định hoặc cấu hình theo ý muốn.\nService auto scaling Giờ thì mình sẽ cấu hình scaling cho container\nMinimun: 1 Maximun: 2 Scaling policy type: Target tracking Cấu hình chính sách cho scaling\nName: ScaleAtThreshold75Percent ECS service metric: ECSServiceAverageCPUUtilization Target value: 75 Scale-out cooldown period: 120 Scale-in cooldown period: 120 Và ấn Create để tạo Chúng ta cần phải đợi khoảng 5 phút để cho Service được tạo hoàn tất.\n"
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Triển khai hạ tầng Terraform tích hợp với GitHub Action",
	"tags": [],
	"description": "",
	"content": "Hạ tầng Terraform tích hợp với GitHub Action Kiến trúc Quy trình Để thực hiện bài Workshop này, chung ta có một quy trình đơn giản như sau:\nViết một hạ tầng Terraform cho hệ thống sẵn. Dùng lệnh để chạy hạ tầng lên AWS console. Triển khai ECS Service trên hạ tầng đã được tạo sẵn Triển khai CI/CD để tự động hóa quá trình. Tạo Monitoring để giám sát quá trình. Quy trình này đảm bảo việc triển khai hạ tầng, dịch vụ và CI/CD được tự động hóa, mang lại hiệu quả cao và khả năng kiểm soát toàn diện cho hệ thống trên AWS.\nNội dung chính Giới thiệu Chuẩn bị Hạ tầng Terraform Thêm cơ sở dư liệu vào RDS Tạo ECS Service Kiểm tra kết quả Triển khai CI/CD với GitHub Action Giám sát Dọn dẹp tài nguyên "
},
{
	"uri": "//localhost:1313/vi/2-preparation/",
	"title": "Chuẩn bị",
	"tags": [],
	"description": "",
	"content": "Nội Dung Chuẩn bị các phụ thuộc Chuẩn bị Elastic Container Registry Tạo Access key, Role và Key pair "
},
{
	"uri": "//localhost:1313/vi/2-preparation/2-ecr/",
	"title": "Chuẩn bị Elastic Container Registry",
	"tags": [],
	"description": "",
	"content": "Chuẩn bị repository trên Amazon ECR Trong phần này, chúng ta sẽ tạo và chuẩn bị các kho lưu trữ ECR. Nếu bạn không quen với việc đẩy hình ảnh lên Amazon ECR, vui lòng tham khảo tài liệu AWS trên Amazon ECR để được hướng dẫn chi tiết về quy trình và các bước cần thiết.\nTạo sẵn 2 repository có tên là frontend và backend. "
},
{
	"uri": "//localhost:1313/vi/3-terraform/2-git/",
	"title": "Git clone template",
	"tags": [],
	"description": "",
	"content": "Clone template Như đã ghi chú ở phần Chuẩn bị bạn cần phải cài đặt sẵn các dependencies ở trên máy mình, và bạn có thể dùng Visual Studio Code để dễ dàng hơn trong việc quản lý các thư mục.\nDùng lệnh để kiểm tra git đã được cài đặt chưa. git -v Tiếp theo sẽ là clone code về để chạy. git clone https://github.com/LyHoangViet/Terraform-DoAn.git cd .\\Terraform-DoAn\\deploy-infrastructure-ecs\\ Đăng nhập vào AWS CLI aws --version aws configure "
},
{
	"uri": "//localhost:1313/vi/7-cicd-github/2-push-code/",
	"title": "Tạo project mới và push code",
	"tags": [],
	"description": "",
	"content": "Tạo mới repository Repository này sẽ là nơi để bạn chạy Github Action.\nĐầu tiên là vào tài khoản Github của bạn. Chọn Repositories. Chọn New. Nhập tên repository: terraform-cicd Nhập mô tả: Use to CI/CD Chọn Public. Chọn Create repository. Hoàn thành tạo Repository. Push code Truy cập vào máy ảo đã clone và sửa code.\nDùng lệnh để remote repo của bạn. Kiểm tra xem đã remote thành công chưa. git remote set-url origin \u0026#34;Link repo github\u0026#34; git remote -v Dùng lệnh để đẩy code lên repo mới tạo của bạn. git add . git commit -m \u0026#34;Fist commit\u0026#34; git branch -M main git push -u origin main Kiểm tra lại trong repo trên Github xem code đã được đẩy lên chưa. "
},
{
	"uri": "//localhost:1313/vi/5-ecs-service/2-frontend/",
	"title": "Triển khai Rolling với Frontend",
	"tags": [],
	"description": "",
	"content": "Tạo ECS Service Frontend Tương tự như Sevice ở bên Backend, bây giờ chúng ta sẽ tạo ở bên Frontend.\nChọn Launch type là FARGATE. Version chọn LATEST. Chọn type là Service. Family chọn Task definition đã tạo cho frontend và chọn version mới nhất. Nhập tên: frontend Chọn type là Replica và chọn 1 task để khởi chạy. Khác với backend phần sau của frontend để chạy mặc định là Rolling. Networking Giờ thì mình sẽ gán Service này và các container vào trong vùng mạng, subnet mà mình đã tạo sẵn bằng hạ tầng Terraform.\nVPC: Chọn VPC mà chúng ta đã tạo trước đó Subnet: Chọn private subnet (DoAn-network-subnet-private3) mà chúng ta đã tạo trong phần chuẩn bị Security group: Chọn DoAn-network-sg-private. Public ip: Phần này sẽ tắt để tăng tính bảo mật hơn vì traffic đã được truyền thông qua Load Balancer rồi. Load balancing Cấu hình một số thông tin của Load Balancer như sau:\nLoad balancing type: chọn Application Load Balancer. Container: frontend 80:80 (port ở đây sẽ là port của host và container). Chọn Use an existing load balancer. Chọn Doan-alb load balance. Health check grace period: 30. Trong phần listener, chúng ta sẽ tạo ra listener đã tạo trước đó ở Terraform.\nChọn Use an existing listener, chọn 80:HTTP Target group, chọn target group mà mình đã tạo ở tại Terraform.\nChọn Use an existing target group, chọn my-tg Kiểm tra lại cấu hình và chọn Create.\nĐợi khoảng 5 phút để service được tạo hoàn tất. "
},
{
	"uri": "//localhost:1313/vi/3-terraform/3-variable/",
	"title": "Chỉnh sửa các biến",
	"tags": [],
	"description": "",
	"content": "Giải thích về các biến Để hiểu rõ hơn về các biến trong hạ tầng Terraform này, bạn có thể xem xét đoạn mã dưới đây cùng với phần ghi chú chi tiết.\n# Setup local variables locals { region = \u0026#34;ap-southeast-1\u0026#34; author = \u0026#34;DUKE\u0026#34; network_root_name = \u0026#34;FCJ-network\u0026#34; vpc_cidr = \u0026#34;10.0.0.0/16\u0026#34; compute_root_name = \u0026#34;FCJ-compute\u0026#34; key_name = \u0026#34;FCJ-Lab-key\u0026#34; # RDS database db_username = \u0026#34;admin\u0026#34; db_password = \u0026#34;letmein12345\u0026#34; db_name = \u0026#34;fcjdb\u0026#34; # Cloud Map service_discovery_namespace_name = \u0026#34;fcjresbar.internal\u0026#34; service_discovery_service_name = \u0026#34;backend\u0026#34; # Load Balancer target_group_name = \u0026#34;my-tg\u0026#34; alb_name = \u0026#34;FCJ-alb\u0026#34; # Task definition of backend backend_family = \u0026#34;fcjresbar-task-be\u0026#34; backend_image = \u0026#34;730335321184.dkr.ecr.ap-southeast-1.amazonaws.com/backend-image\u0026#34; mysql_database = \u0026#34;fcjresbar\u0026#34; db_dialect = \u0026#34;mysql\u0026#34; be_port = \u0026#34;5000\u0026#34; jwt_secret = \u0026#34;0bac010eca699c25c8f62ba86e319c2305beb94641b859c32518cb854addb5f4\u0026#34; # Task definition of frontend frontend_family = \u0026#34;fcjresbar-task-fe\u0026#34; frontend_image = \u0026#34;730335321184.dkr.ecr.ap-southeast-1.amazonaws.com/frontend-image\u0026#34; be_host = \u0026#34;backend.fcjresbar.internal\u0026#34; ec2_instances = [ { name = \u0026#34;server_test\u0026#34; ami = \u0026#34;ami-06650ca7ed78ff6fa\u0026#34; # Ubuntu Server 24.04 LTS instance_type = \u0026#34;t2.medium\u0026#34; subnet_id = module.infrastructure_vpc.subnet_public1_id security_group_ids = [module.security.public_sg_id] }, ] } Lưu ý: Các biến trên để có thể hoạt động tốt, bạn cần phải thay đổi đúng theo các thông số cấu hình của bạn.\nĐường dẫn tới code vi .\\deploy-infrastructure-ecs\\variable.tf "
},
{
	"uri": "//localhost:1313/vi/3-terraform/",
	"title": "Hạ tầng Terraform",
	"tags": [],
	"description": "",
	"content": "Nội Dung Giới thiệu về hạ tầng Git clone template Chỉnh sửa các biến Chạy lệnh Terraform "
},
{
	"uri": "//localhost:1313/vi/7-cicd-github/3-secret-key/",
	"title": "Thêm Secret key",
	"tags": [],
	"description": "",
	"content": "Tạo secret key trong Github Tạo secret key cho github để có thể dùng các giá trị này gán vào các biến ở trong CI/CD để nó được hoạt động đúng cách.\nVào phần Settings của repository bạn đã tạo từ phần trước. Chọn Secrets and variables và Actions như hướng dẫn. Chọn New repository secret để tạo secret. Thêm các giá trị như hình sau đây vào:\nAWS_ACCESS_KEY_ID gán giá trị access key vừa tạo trong aws vào. AWS_SECRET_ACCESS_KEY gán giá trị secret key vừa tạo trong aws vào. AWS_REGION gán giá trị bằng region bạn đang sử dụng. AWS_ACCOUNT_NUMBER gán số account của bạn đang sử dụng. DOCKER_PASSWORD gán mật khẩu hoặc token ở tài khoản Docker của bạn. DOCKER_USERNAME gán username ở tài khoản Docker của bạn. CLUSTER_NAME gán giá trị bằng tên Cluster ECS. TASK_NAME_BE gán giá trị bằng tên task definition của backend. TASK_NAME_FE gán giá trị bằng tên task definition của frontend. SERVICE_NAME_BE gán giá trị bằng tên Sevice name của backend. SERVICE_NAME_FE gán giá trị bằng tên Sevice name của frontend. AWS_APPLICATION_NAME gán giá trị bằng tên Application ở trong CodeDeploy của backend. AWS_DEPLOYMENT_GROUP_NAME gán giá trị bằng tên Deployment group ở trong Application của backend. Vì repository đang sử dụng Docker Hub để chứa images, nếu bạn muốn sử dụng một nơi lưu trữ khác như ECR, cần phải chỉnh sửa lại các biến trong file cấu hình để phù hợp với ECR.\n"
},
{
	"uri": "//localhost:1313/vi/3-terraform/4-command/",
	"title": "Chạy lệnh Terraform",
	"tags": [],
	"description": "",
	"content": "Run Command Bây giờ, mình sẽ chạy lệnh để triển khai các hạ tầng đã được cấu hình này lên trên hạ tầng AWS.\nChạy lệnh để khởi tạo hạ tầng. terraform init Dùng lệnh tiếp theo để theo dõi trước những thay đổi trong hạ tầng sẽ được áp dụng. terraform plan Lệnh cuối cùng dùng để áp dụng các hạ tầng đã cấu hình lên AWS. terraform apply Nhập yes. Đợi khoảng 15 đến 20 phút để hạ tầng được tạo hoàn tất. Kiểm tra kết quả Sau khi chạy hoàn tất, chúng ta sẽ vào AWS console để kiểm tra trên giao diện xem các hạ tầng đã được tạo hoàn tất chưa.\nVào kiểm tra bên trong VPC. Kiểm tra ở EC2 instance. Truy cập vào RDS. Kiểm tra ECS cluster. Kiểm tra Task definition. Kiểm tra các dịch vụ ở Cloud Map. "
},
{
	"uri": "//localhost:1313/vi/4-database/",
	"title": "Thêm cơ sở dư liệu vào RDS",
	"tags": [],
	"description": "",
	"content": "Kết nối vào EC2 Instance Đầu tiên mình cần truy cập vào instance đã được tạo bởi Terraform và truy cập vào nó để add dữ liệu cho RDS.\nTìm kiếm ECS Instance trong AWS console. Chọn tên instance mình đã tạo và chọn Connect. Chọn SSH client. Copy đường dẫn như hình. Dán vào bên trong VS Code của mình và cấu hình lại đường dẫn của Key pair mình đã lưu. Kết nối thành công. Add Database Bởi vì trong cấu hình Terraform của mình đã setup sẵn các dependencies và có cả cơ sở dữ liệu mẫu trong đó, vì thế nên việc add data vào RDS sẽ trở nên dễ dàng hơn.\nBây giờ, chúng ta sẽ đi vào thư mục đã được setup sẵn và thêm đường dẫn tuyệt đối cho phần cơ sở dữ liệu trong này.\nChúng ta sẽ dùng lệnh sau. cd ./aws-fcj-container-app/database/ echo $PWD/init.sql Tiếp theo ta cần đăng nhập vào RDS để add data ở trong đường dẫn đó vào.\nCopy Endpoint của RDS. Dùng endpoint đó để dán vào lệnh sau. mysql -h \u0026#34;rds-endpoint\u0026#34; -u \u0026#34;name-user\u0026#34; -p Dán lệnh trên vào trong máy ảo và nhập password để kết nối tới RDS. Dán đường dẫn có data vào trong RDS đang được kết nối. source /home/ubuntu/aws-fcj-container-app/database/init.sql Add dữ liệu thành công. Dùng một số lệnh để kiểm tra database. SHOW DATABASES; USE fcjresbar; SELECT * FROM Clients; "
},
{
	"uri": "//localhost:1313/vi/7-cicd-github/4-result/",
	"title": "Kiểm tra kết quả",
	"tags": [],
	"description": "",
	"content": "Tạo tag Để CI/CD được chạy, chúng ta cần phải tạo tag mới cho code.\nVào lại repository của bạn. Chọn vào Tags. Chọn Releases. Chọn Draft a new release. Nhập tên tag mới: v1.0.4 Chọn Create new tag. Chọn Publish release để tạo thành công. Kiểm tra kết quả Để theo dõi tiến trình CI/CD, các bạn sẽ làm theo các bước sau:\nVào phần Actions. Chọn vào tên tiến trình mình đã đặt. Xem quá trình CI/CD của backend và frontend tại đây. Nếu lỗi thì xem logs ở bên dưới. Sau khi CI/CD chạy thành công, bạn sẽ lên giao diện AWS console để kiểm tra xem các thành phần như Task definition và Service đã được update hay chưa.\nVào Task definitions kiểm tra xem có task mới nào được tạo chưa. Đầu tiên vào vào task của Backend. Tiếp theo là vào task của frontend. Kiểm tra Service đang được update. Sau khi đã hoàn thành tất cả, bạn sẽ vào lại DNS của Load balancer để kiểm tra phần thay đổi của bạn đã được update hay chưa.\nLoad lại trang hiện tại. "
},
{
	"uri": "//localhost:1313/vi/5-ecs-service/",
	"title": "Tạo ECS Service",
	"tags": [],
	"description": "",
	"content": "Nội Dung Triển khai Blue/Green và Service Scaling với Backend Triển khai Rolling với Frontend "
},
{
	"uri": "//localhost:1313/vi/6-result/",
	"title": "Kiểm tra kết quả",
	"tags": [],
	"description": "",
	"content": "Kiểm tra Application Để kiểm tra Application, bạn cần lấy domain từ Load Balancer.\nTìm kiếm từ khóa Load Balancers trên AWS Console. Chọn vào Load Balancer đã được tạo trong hạ tầng Terraform. Copy DNS name của Load Balancer đã tạo. Dán link DNS vào trình duyệt để khởi động ứng dụng. Đăng nhập vào và kiểm tra các chức năng của từng phần. Chúc mừng bạn đã triển khai ứng dụng thành công. "
},
{
	"uri": "//localhost:1313/vi/7-cicd-github/",
	"title": "Triển khai CI/CD với GitHub Action",
	"tags": [],
	"description": "",
	"content": "Nội Dung Clone GitHub template Tạo project mới và push code Thêm Secret key Kiểm tra kết quả "
},
{
	"uri": "//localhost:1313/vi/8-monitoring/",
	"title": "Giám sát",
	"tags": [],
	"description": "",
	"content": "Cấu hình Container Insights (CloudWatch) Trong phần này thì chúng ta sẽ phải cấu hình một số thứ trước khi có thể dùng được Container Insights. Container Insights là một dịch vụ mà cho phép chúng ta có thể quan sát được các thông số như mức sử dụng CPU, Network, … từ đó có thể suy ra được lượng người dùng trong một khoảng thời gian nào đó.\nKết hợp với CloudWatch thì chúng ta có thể xem được các logs được gửi từ trong Container dưới dạng các groups, thông thường thì tên group sẽ bắt đầu với tiền tố là /ecs/*. Khi đó thì chúng ta sẽ có cái nhìn tổng quát hơn về các ứng dụng trong hệ thống, như là đang chạy như thế nào, có cảnh báo gì không, hay là khi có một ứng dụng nào đó bị lỗi thì chúng ta có thể đọc các logs đó để tìm ra nguyên nhân, hoặc cũng có thể điều tra được các traffic bất thường khi hệ thống bị xâm nhập.\nTrong trang console của ECS, ở menu bên phải, chọn Account settings. Chọn Update. Chọn Container Insights. Chọn Save changes. Hoàn thành tạo cấu hình Container insight. Quan sát các thông số với Performance Monitoring Vào lại Clusters. Chọn Metrics. Chọn vào View Container Insights để quan sát. Quan sát các thông số với ECS. Nếu như chúng ta muốn đổi sang quan sát Task definitions thì làm theo các bước sau:\nỞ phần đang được khoanh trong hình, bạn đổi thành ECS Tasks để theo dõi được các sự kiện ở đây. Tương tự nếu như muốn đổi qua xem các sự kiện ở bên ECS Service thì làm như sau:\nỞ phần đang được khoanh trong hình, bạn đổi thành ECS Service để theo dõi được các sự kiện ở đây. Quan sát các thông số với Container Map Ở trong phần này thì chúng ta có thể xem được trong Cluster mà chúng ta đã triển khai thì có những Containers nào, Tasks nào, Services nào, … một cách cụ thể hơn.\nThay đổi Performance Monitoring thành Container Map. Sau đó chúng ta sẽ thấy được giao diện mới, trong này, bạn có thể thấy được là một Cluster nó sẽ quản lý các tài nguyên có liên quan như Services, Tasks. Nhưng các thông số trong một Task sẽ khác với các thông số trong một Service, vì Service sẽ quản lý trực tiếp các Task, nên các thông số thuộc Task cũng sẽ thuộc Service.\nỞ đây các bạn cũng có thể xem chi tiếng từng dịch vụ.\nChọn vào Service backend. Chọn vào Metrics. Tương tự thì bạn cũng có thể xem các Task definition.\nChọn vào Task fe. Chọn Metrics. Quan sát các thông số với Resources Đổi Container map thành Resources. Ở đây, các bạn sẽ thấy được một list danh sách các sự kiện mình đã tạo, có thể chọn và từng dịch vụ để giám sát.\nNhưng vậy thì chúng ta đã cấu hình và thực hành xong phần quan sát với Container Insights, nhưng AWS không chỉ giới hạn dịch vụ quan sát, theo dõi hệ thống trong Container Insights mà chúng ta cũng có thể dùng các dịch vụ khác hoặc các dịch vụ bên thứ 3 để làm việc đó.\nChúc mừng bạn đã hoàn thành được bài Workshop này!\n"
},
{
	"uri": "//localhost:1313/vi/9-clean-up/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Dọn dẹp trên AWS console Đầu tiên các bạn cần phải truy cập vào AWS console để xóa các dịch vụ mà các bạn đã tạo thủ công trước.\nTrong trang console, tìm kiếm từ khóa CloudFormation. Chọn Stacks. Chọn 2 Service mình đã tạo và chọn Delete. Chọn Delete. Đợi khoảng 5 đến 10 phút để quá trình xóa hoàn thành. Vào lại ECS cluster xem service đã được xóa chưa. Dọn dẹp bằng lệnh Terraform Bởi vì các tài nguyên trong hạ tầng đã được tạo bởi Terraform, vì thế Terraform có một cái rất là tiện lợi đó là chỉ cần dùng một dòng lệnh duy nhất để có thể xóa hết tài nguyên mà không cần phải xóa thủ công từng cái một.\nBây giờ mình sẽ vào lại nơi mình đã chạy hạ tầng bằng Terraform.\nDùng lệnh để xóa tài nguyên. terraform destroy Nhập yes để xác nhận. Đợi khoảng 15 đến 20 phút để có thể xóa hết tài nguyên. Sau khi xóa thành công, các bạn nên vào lại AWS console kiểm tra lại các tài nguyên xem đã được xóa hết chưa. "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]